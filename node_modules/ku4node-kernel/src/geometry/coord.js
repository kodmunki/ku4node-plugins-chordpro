var $ = require("../base/asserters"),
    $str = require("../base/str"),
    $math = require("../base/math"),
    $class = require("../base/class");

function coord(x, y) {
    if (!$.isNumber(x) || !$.isNumber(y))
        throw new Error($str.format("at $coord({0},{1})", x, y));

    coord.base.call(this);
    this.x(x).y(y);
}

coord.prototype = {
    x: function(x){ return this.property("x", x); },
    y: function(y){ return this.property("y", y); },
    abs: function(){
        return new coord(Math.abs(this._x), Math.abs(this._y));
    },
    add: function(other) {
        var x = this._x + other.x(),
            y = this._y + other.y();
        return new coord(x,y);
    },
    divide: function(other) {
        var x = this._x / other.x(),
            y = this._y / other.y();
        return new coord(x, y);
    },
    equals: function(other) {
        return (this._x === other.x()) && (this._y === other.y());
    },
    multiply: function(other) {
        var x = this._x * other.x(),
            y = this._y * other.y();
        return new coord(x, y);
    },
    subtract: function(other) {
        var x = this._x - other.x(),
            y = this._y - other.y();
        return new coord(x, y);
    },
    round: function(decimal){
        var d = decimal || 0;
        return new coord($math.round(this.x(), d), $math.round(this.y(), d));
    },
    half: function(){ return this.divide(new coord(2, 2)); },
    value: function() { return { x: this._x, y: this._y }; },
    toString: function() { return $str.format("({0},{1})", this._x, this._y); }
}
$class.extend(coord, $class);

function toUnit(coord, unit) {
    return {
        x: function() { return coord.x() + unit; },
        y: function() { return coord.y() + unit; }
    }
}
function canParse(candidate){
    try{
        if (("left" in candidate) && ("top" in candidate))
            return !isNaN(candidate.left) && !isNaN(candidate.top);
        if (("width" in candidate) && ("height" in candidate))
            return !isNaN(candidate.width) && !isNaN(candidate.height);
        return false;
    }
    catch(e) { return false; }
}
function parse(obj) {
    if (("left" in obj) && ("top" in obj)) return new coord(obj.left, obj.top);
    if (("width" in obj) && ("height" in obj)) return new coord(obj.width, obj.height);
    throw new Error("at $coord.parse");
}

module.exports = function(x, y) { return new coord(x, y); }
module.exports.Class = coord;
module.exports.zero = function(){ return new coord(0,0); }
module.exports.random = function(seedx, seedy){
    var x = seedx * Math.random(), y = seedy * Math.random(seedy);
    return new coord(x, y);
}
module.exports.canParse = canParse;
module.exports.parse = parse;
module.exports.tryParse = function(o){ return canParse(o) ? parse(o) : null; }