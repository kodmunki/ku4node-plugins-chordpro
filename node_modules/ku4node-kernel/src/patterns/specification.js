var $ = require("../base/asserters"),
    $class = require("../base/class");

function abstractSpec() { }
abstractSpec.prototype = {
    $isSatisfiedBy: function(v) { return; },
    isSatisfiedBy: function(v) {return this.$isSatisfiedBy(v);},
    and: function(spec) { return new andSpec(this, spec); },
    or: function(spec) { return new orSpec(this, spec); },
    xor: function(spec) { return new xorSpec(this, spec); },
    not: function() { return new notSpec(this); }
}

function andSpec (a, b) {
    this.$1 = a;
    this.$2 = b;
}
andSpec.prototype.$isSatisfiedBy = function(c) {
    return this.$1.isSatisfiedBy(c) &&
           this.$2.isSatisfiedBy(c);
}
$class.extend(andSpec, abstractSpec);

function orSpec(a, b) {
    this.$1 = a;
    this.$2 = b;
}
orSpec.prototype.$isSatisfiedBy = function(candidate) {
    return this.$1.isSatisfiedBy(candidate) ||
           this.$2.isSatisfiedBy(candidate);
}
$class.extend(orSpec, abstractSpec);

function xorSpec(a, b) {
    this.$1 = a;
    this.$2 = b;
}
xorSpec.prototype.$isSatisfiedBy = function(candidate) {
    return $.xor(this.$1.isSatisfiedBy(candidate),
                 this.$2.isSatisfiedBy(candidate));
}
$class.extend(xorSpec, abstractSpec);

function trueSpec() { trueSpec.base.call(this); }
trueSpec.prototype.$isSatisfiedBy = function(candidate) { return true; }
$class.extend(trueSpec, abstractSpec);

function falseSpec() { falseSpec.base.call(this); }
falseSpec.prototype.$isSatisfiedBy = function(candidate) { return false; }
$class.extend(falseSpec, abstractSpec);

function notSpec(s) { this._s = s; }
notSpec.prototype.$isSatisfiedBy = function(candidate) {
    return !this._s.isSatisfiedBy(candidate);
}
$class.extend(notSpec, abstractSpec);

function spec(func){ this.$isSatisfiedBy = func; }
$class.extend(spec, abstractSpec);

module.exports = function(func){ return new spec(func); }